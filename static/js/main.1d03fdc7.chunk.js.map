{"version":3,"sources":["Visualizer/Drawer.js","Parser/Downloader.js","Parser/Helper.js","Parser/FragmentHandler.js","Visualizer/SignalGroupDrawer.js","Visualizer/Components/PredictionBox/Countdown/Countdown.js","Visualizer/Components/PredictionBox/MinMaxTable/MinMaxTable.js","Visualizer/Components/PredictionBox/Graph/BarChart.js","Visualizer/Components/PredictionBox/PhaseColorGraph/PhaseColorGraph.js","Visualizer/Components/PredictionBox/Selector/Dropdown.js","Visualizer/Components/PredictionBox/Error/ErrorBox.js","Prediction/Readers/FragmentParser.js","Prediction/Predictor/PredictionCalculator.js","Prediction/Predictor/PredictionManager.js","Prediction/Distributions/Types/TimeFrequencyDistribution.js","Prediction/PredictionGenerator.js","Visualizer/Components/PredictionBox/PredictionBox.js","Visualizer/Components/CompareView/CompareView.js","App.js","serviceWorker.js","index.js"],"names":["DataFactory","n3","namedNode","Downloader","literal","defaultGraph","quad","Component","_url","Promise","resolve","reject","fetch","then","response","text","catch","err","console","error","e","Helper","_doc","parser","Parser","store","Store","parse","prefixes","addQuad","_ref","Object","asyncToGenerator","regenerator_default","a","mark","_callee","writer","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_iterator","_step","wrap","_context","prev","next","Writer","undefined","getQuads","Symbol","iterator","done","value","t0","return","finish","end","result","stop","_x","apply","this","arguments","timeDate","toDate","Date","getUTCHours","getUTCMonth","getUTCMinutes","getUTCDay","getUTCFullYear","FragmentHandler","fragment","returnObject","signalGroups","parseAndStoreQuads","forEach","push","subject","sort","b","object","getTime","observation","generatedAtTime","signalGroup","signalState","minEndTime","maxEndTime","signalPhase","likelyTime","log","Countdown","_this$props","props","count","color","textColor","react_default","createElement","className","style","MinMaxTable","min","max","LineChart","minData","maxData","likelyData","title","es","height","width","xType","data","barWidth","PhaseColorGraph","red","orange","green","ticks","stroke","fill","Dropdown","activeValue","options","onChange","event","target","keys","map","key","id","ErrorBox","_this","classCallCheck","possibleConstructorReturn","getPrototypeOf","call","state","show","onClick","bind","assertThisInitialized","setState","message","FragmentParser","showGeneratedAtTimeErrors","length","showPhaseErrors","phaseStart","lastPhase","lastMaxEndTime","lastMinEndTime","lastObservation","maxDidIncrease","startUpObservations","generatedBeforeLastErrors","onSamePhaseResets","onPhaseChangeResets","observationSameAsLast","realStartUpObservations","realStartUp","file","onPhaseChange","onSamePhase","onObservationBeforeValidityCheck","afterHandle","onFragmentError","_initReturnObject","isFragmentValid","firstObservation","firstObservationName","replace","_setReturnObject","lastPhaseStart","PredictionCalculator","frequencyDistribution","weightedSum","duration","Math","round","runner","median","i","list","parseInt","part","PredictionManager","distribution","predictionCalculatorFunction","elapsedDuration","futureDistribution","predictedDuration","setTime","toISOString","lastPhaseDuration","lastPredictedDuration","lastPredictionRelativeError","calculatePartDuration","TimeFrequencyDistribution","year","month","day","hour","minutes","output","PredictionGenerator","realTimeFragmentParser","timeDistribution","handleFragment","observationUTC","splitDateInParts","phaseDuration","add","floor","get","predictLikelyTime","calculateMedianDuration","writeN3Store","res","_x2","PredictionBox","DATASET_URL","datasetUrl","_constructGraphData","_constructColorGraphData","_constructSignalGroup","setActiveSignalGroup","clientSidePrediction","predictionGenerator","colorData","colorDataOldest","minEndTimeGraphData","maxEndTimeGraphData","likelyTimeGraphData","activeSignalGroup","_this2","setInterval","download","parsed","generatePredictions","sent","_this$state","deletedPhase","shift","x","y","newState","type","graph","graphData","countdown","newSignalGroups","_this$state2","sg","_this$state3","redData","greenData","orangeData","Array","prototype","Selector_Dropdown","Countdown_Countdown_Countdown","MinMaxTable_MinMaxTable_MinMaxTable","BarChart","PredictionBox_PhaseColorGraph_PhaseColorGraph","ErrorBox_ErrorBox","App","PredictionBox_PredictionBox_PredictionBox","Boolean","window","location","hostname","match","ReactDOM","render","src_App","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.1d03fdc7.chunk.js","sourcesContent":["import React, { Component } from 'react';\r\nimport n3 from 'n3';\r\n\r\nconst { DataFactory } = n3;\r\nconst { namedNode, literal, defaultGraph, quad } = DataFactory;\r\n\r\nclass Drawer extends Component {\r\n\r\n    constructor(props){\r\n        super(props);\r\n        this.DATASET_URL = 'https://lodi.ilabt.imec.be/observer/rawdata/latest';\r\n        this.SPEED = 0;\r\n        this.signalgroups = [];\r\n        this.prevGatGreen = [];\r\n        this.lastGat = null;\r\n        this.AMOUNT_OF_FRAGMENTS = 15;\r\n\r\n        this.vertreklanen = {};\r\n        this.data = {};\r\n\r\n        this.lanes = {};    // hash to translate id to description\r\n\r\n        this.state = {\r\n            laneValues: {}, //contains the\r\n            minEndTimes: {},\r\n            maxEndTimes: {},\r\n        };\r\n\r\n    }\r\n\r\n    sleep(milliseconds){\r\n        return new Promise(resolve => setTimeout(resolve, milliseconds))\r\n    }\r\n\r\n    initConfiguration(_store){\r\n        console.log(\"initConfiguration\");\r\n        let laneValues = {};\r\n        let minEndTimes = {};\r\n        let maxEndTimes = {};\r\n        _store.getQuads(null, namedNode('https://w3id.org/opentrafficlights#departureLane'), null).forEach((quad) => {\r\n            _store.getQuads(quad.object, namedNode('http://purl.org/dc/terms/description'), null).forEach( (quad) => {\r\n                _store.getQuads(null, namedNode('https://w3id.org/opentrafficlights#departureLane'), quad.subject).forEach((connectie) => {\r\n                    let signalgroup = _store.getQuads(connectie.subject, namedNode('https://w3id.org/opentrafficlights#signalGroup'), null)[0].object.value;        //why 0 ?\r\n                    console.log(\"signalGroup\");\r\n                    let test = _store.getQuads(connectie.subject, namedNode('https://w3id.org/opentrafficlights#signalGroup'), null)[0].object.value;\r\n                    console.log(test);\r\n                    _store.getQuads(connectie.subject, namedNode('https://w3id.org/opentrafficlights#arrivalLane'), null).forEach( (arrivalLane) => {\r\n                        _store.getQuads(arrivalLane.object, namedNode('http://purl.org/dc/terms/description'), null).forEach( (descr) => {\r\n                            if(!this.vertreklanen[quad.subject.value]) this.vertreklanen[quad.subject.value] = [];\r\n                            this.vertreklanen[quad.subject.value][arrivalLane.object.value] = {\r\n                                '@id': arrivalLane.object.value,\r\n                                'http://purl.org/dc/terms/description': descr.object.value,\r\n                                'https://w3id.org/opentrafficlights#signalGroup': signalgroup       // why?\r\n                            };\r\n                            if(!laneValues[quad.subject.value]) laneValues[quad.subject.value] = {};\r\n                            laneValues[quad.subject.value][arrivalLane.object.value] = [\"initial\",\"initial\"];\r\n                            if(!this.lanes[arrivalLane.object.value]){\r\n                                this.lanes[arrivalLane.object.value] = descr.object.value;\r\n                            }\r\n                            if(!minEndTimes[quad.subject.value]) minEndTimes[quad.subject.value] = {};\r\n                            if(!maxEndTimes[quad.subject.value]) maxEndTimes[quad.subject.value] = {};\r\n                            minEndTimes[quad.subject.value][arrivalLane.object.value] = 0;\r\n                            maxEndTimes[quad.subject.value][arrivalLane.object.value] = 0;\r\n                        });\r\n                    });\r\n\r\n                    if(!this.lanes[quad.subject.value]){\r\n                        this.lanes[quad.subject.value] = quad.object.value;\r\n                    }\r\n\r\n                });\r\n            });\r\n        });\r\n        //console.log(laneValues);\r\n        this.setState({laneValues: laneValues, minEndTimes: minEndTimes, maxEndTimes: maxEndTimes});\r\n        //console.log(this.vertreklanen);\r\n    }\r\n\r\n    async getSignalgroups(_store) {\r\n        let signalgroups = [];\r\n        await _store.getQuads(null, namedNode('http://www.w3.org/2000/01/rdf-schema#type'), namedNode('https://w3id.org/opentrafficlights#Signalgroup')).forEach( (quad) => {\r\n            signalgroups.push(quad.subject.value);\r\n        });\r\n        return signalgroups;\r\n    }\r\n\r\n    download(_url) {\r\n        return new Promise(resolve => {\r\n            fetch(_url)\r\n                .then(function(response) {\r\n                    return response.text();\r\n                })\r\n                .then(function(text) {\r\n                    resolve(text);\r\n                });\r\n        });\r\n    }\r\n\r\n    parseAndStoreQuads(_doc) {\r\n        return new Promise(resolve => {\r\n            const parser = new n3.Parser();\r\n            const store = new n3.Store();\r\n            parser.parse(_doc, (error, quad, prefixes) => {\r\n                if (quad)\r\n                    store.addQuad(quad);\r\n                else\r\n                    return resolve(store);\r\n            });\r\n        })\r\n    }\r\n\r\n    async calcHistoricData(_store) {\r\n        // Loop over observations order descending\r\n        let observations = _store.getQuads(null, namedNode('http://www.w3.org/ns/prov#generatedAtTime'), null);\r\n        observations.sort(function(a, b) {\r\n            a = new Date(a.object.value).getTime();\r\n            b = new Date(b.object.value).getTime();\r\n\r\n            return a>b ? -1 : a<b ? 1 : 0;\r\n        }).forEach((observation) => {\r\n            let generatedAtTime = new Date(observation.object.value);\r\n\r\n            if(generatedAtTime !== this.lastGat){\r\n                //console.log(new Date() - generatedAtTime);\r\n                //console.log(generatedAtTime);\r\n                this.lastGat = generatedAtTime;\r\n            }\r\n\r\n            // Loop over all signalstates in the observation\r\n            _store.getQuads(null, namedNode('https://w3id.org/opentrafficlights#signalState'), null, observation.subject).forEach((signalstateQuad) => {\r\n                let signalgroup = signalstateQuad.subject.value;\r\n                let signalphase = _store.getQuads(signalstateQuad.object, namedNode('https://w3id.org/opentrafficlights#signalPhase'), null, observation.subject)[0];\r\n                let timeTillGreen;\r\n                // When green\r\n                if (signalphase.object.value === 'https://w3id.org/opentrafficlights/thesauri/signalphase/6') {\r\n                    this.prevGatGreen[signalgroup] = generatedAtTime;\r\n                    timeTillGreen = 0;\r\n                }\r\n\r\n                if (this.prevGatGreen[signalgroup] != null){ //does not work with !==\r\n                    timeTillGreen = (this.prevGatGreen[signalgroup].getTime() - generatedAtTime.getTime())/1000;\r\n\r\n                    // There's probably a data gap when this is very big\r\n                    if (timeTillGreen < 100) {\r\n                        if (!this.data[signalgroup]) this.data[signalgroup] = [];\r\n\r\n                        this.data[signalgroup].unshift({\r\n                            'generatedAtTime': new Date(generatedAtTime),\r\n                            'timeTillGreen': timeTillGreen\r\n                        })\r\n                    }\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    async start() {\r\n        console.log(\"async funtion start\");\r\n        let doc = await this.download(this.DATASET_URL);\r\n        let store = await this.parseAndStoreQuads(doc);\r\n        this.signalgroups = await this.getSignalgroups(store);\r\n        this.initConfiguration(store);\r\n\r\n        // Init\r\n        this.signalgroups.forEach((sg) => {\r\n            this.prevGatGreen[sg] = null;\r\n            this.data[sg] = [];\r\n        });\r\n\r\n        while(true) {\r\n            await this.calcHistoricData(store);\r\n            this.showLatest(store);\r\n\r\n            // let count = 0;\r\n\r\n            // HISTORY\r\n            // let prev = store.getQuads(null, namedNode('http://www.w3.org/ns/hydra/core#previous'), null)[0];\r\n            // while (prev && count < this.AMOUNT_OF_FRAGMENTS) {\r\n            //     count++;\r\n            //\r\n            //     doc = await this.download(prev.object.value);\r\n            //     store = await this.parseAndStoreQuads(doc);\r\n            //\r\n            //     await this.calcHistoricData(store);\r\n            //\r\n            //     prev = store.getQuads(null, namedNode('http://www.w3.org/ns/hydra/core#previous'), null)[0];\r\n            // }\r\n\r\n            doc = await this.download(this.DATASET_URL);\r\n            store = await this.parseAndStoreQuads(doc);\r\n\r\n            this.signalgroups.forEach((sg) => {\r\n                this.prevGatGreen[sg] = null;\r\n                this.data[sg] = [];\r\n            });\r\n\r\n            await this.sleep(this.SPEED)\r\n        }\r\n    }\r\n\r\n    async showLatest(_store) {\r\n        // Loop over observations order descending\r\n        let observations = _store.getQuads(null, namedNode('http://www.w3.org/ns/prov#generatedAtTime'), null);\r\n        //console.log(\"observations: \");\r\n        //console.log(observations);\r\n        let latest = observations.sort(function(a, b) {\r\n            a = new Date(a.object.value).getTime();\r\n            b = new Date(b.object.value).getTime();\r\n\r\n            return a>b ? -1 : a<b ? 1 : 0;\r\n        })[0];\r\n\r\n        let generatedAtTime = latest.object.value;\r\n        //console.log(\"latest: \");\r\n        //console.log(latest);\r\n\r\n        let doc = this;\r\n        let laneValues = this.state.laneValues;\r\n        let minEndTimes = this.state.minEndTimes;\r\n        let maxEndTimes = this.state.maxEndTimes;\r\n        Object.keys(this.vertreklanen).forEach(\r\n            function (fromLane) {\r\n                Object.keys(doc.vertreklanen[fromLane]).forEach(\r\n                    function (toLane) {\r\n                        let signal = doc.vertreklanen[fromLane][toLane]['https://w3id.org/opentrafficlights#signalGroup'];\r\n                        let signalstate = _store.getQuads(namedNode(signal), namedNode('https://w3id.org/opentrafficlights#signalState'), null, latest.subject)[0];\r\n                        if (signalstate) {\r\n                            let minEndTime = _store.getQuads(signalstate.object, namedNode('https://w3id.org/opentrafficlights#minEndTime'), null, latest.subject)[0];\r\n                            let maxEndTime = _store.getQuads(signalstate.object, namedNode('https://w3id.org/opentrafficlights#maxEndTime'), null, latest.subject)[0];\r\n                            let signalPhase = _store.getQuads(signalstate.object, namedNode('https://w3id.org/opentrafficlights#signalPhase'), null, latest.subject)[0];\r\n\r\n                            let count = Math.round((new Date(minEndTime.object.value).getTime() - new Date(generatedAtTime).getTime())/1000);\r\n                            if (minEndTime.object.value === maxEndTime.object.value) {\r\n                                laneValues[fromLane][toLane] = [count, signalPhase.object.value];\r\n                                //this.showCounterLabel(count, signalPhase.object.value);\r\n                            } else {\r\n                                laneValues[fromLane][toLane] = [\">\" + count, signalPhase.object.value];\r\n                                //this.showCounterLabel(\"> \" + count, signalPhase.object.value);\r\n                            }\r\n                            minEndTimes[fromLane][toLane] = Math.round((new Date(minEndTime.object.value).getTime() - new Date(generatedAtTime).getTime())/1000);\r\n                            maxEndTimes[fromLane][toLane] = Math.round((new Date(maxEndTime.object.value).getTime() - new Date(generatedAtTime).getTime())/1000);\r\n                        }\r\n\r\n                    }\r\n                )\r\n\r\n            }\r\n        );\r\n\r\n        this.setState({\r\n            laneValues: laneValues,\r\n            minEndTimes: minEndTimes,\r\n            maxEndTimes: maxEndTimes,\r\n        })\r\n\r\n    }\r\n\r\n    showCounterLabel(counter_, label_) {\r\n        const info = '<h3>' + counter_ + \" seconden</h3>\";\r\n\r\n        // const info = '<h3 style=\"float: left\">' + label_ + '</h3><h1 style=\"font-size: 100px;\">' + counter_ + '</h1></div>';\r\n        if (label_ === 'https://w3id.org/opentrafficlights/thesauri/signalphase/2' || label_ === 'https://w3id.org/opentrafficlights/thesauri/signalphase/3') {\r\n            // Red\r\n\r\n        }\r\n        else if (label_ === 'https://w3id.org/opentrafficlights/thesauri/signalphase/5' || label_ === 'https://w3id.org/opentrafficlights/thesauri/signalphase/6') {\r\n            // green\r\n        }\r\n        else {\r\n            // orange\r\n        }\r\n        return info;\r\n    }\r\n\r\n    componentDidMount(){\r\n        console.log(\"componentDidMount\");\r\n        this.start();\r\n    }\r\n\r\n    render() {\r\n        console.log(\"render\");\r\n        const {laneValues, minEndTimes, maxEndTimes} = this.state;\r\n        let doc = this;\r\n        return (\r\n            <div className=\"Drawer\">\r\n                <table>\r\n                    <thead>\r\n                    <tr>\r\n                        <th>From Lane:</th>\r\n                        <th>To Lanes:</th>\r\n                    </tr>\r\n                    </thead>\r\n                    <tbody>\r\n                    {Object.keys(this.vertreklanen).map(\r\n                        function (fromLane) {\r\n                            return (\r\n                                <tr><td>{fromLane}:{doc.lanes[fromLane]}</td>{Object.keys(doc.vertreklanen[fromLane]).map(\r\n                                    function (toLane) {\r\n                                        const label_= laneValues[fromLane][toLane] ? laneValues[fromLane][toLane][1] : \"fail\";\r\n                                        const count = laneValues[fromLane][toLane] ? laneValues[fromLane][toLane][0] : \"fail\";\r\n                                        if (label_ === 'https://w3id.org/opentrafficlights/thesauri/signalphase/2' || label_ === 'https://w3id.org/opentrafficlights/thesauri/signalphase/3') {\r\n                                            // Red\r\n                                            return (<td>{toLane}:{doc.lanes[toLane]}<p style={{color: 'red'}}>simpleCountdown: {count}</p><div><p>minEndTime: {minEndTimes[fromLane][toLane]}</p><p>maxEndTime: {maxEndTimes[fromLane][toLane]}</p></div></td>);\r\n                                        }\r\n                                        else if (label_ === 'https://w3id.org/opentrafficlights/thesauri/signalphase/5' || label_ === 'https://w3id.org/opentrafficlights/thesauri/signalphase/6') {\r\n                                            // green\r\n                                            return (<td>{toLane}:{doc.lanes[toLane]}<p style={{color: 'green'}}>simpleCountdown: {count}</p><div><p>minEndTime: {minEndTimes[fromLane][toLane]}</p><p>maxEndTime: {maxEndTimes[fromLane][toLane]}</p></div></td>);\r\n                                        }\r\n                                        else {\r\n                                            // orange\r\n                                            return (<td>{toLane}:{doc.lanes[toLane]}<p style={{ color: 'orange'}}>simpleCountdown: {count}</p><div><p>minEndTime: {minEndTimes[fromLane][toLane]}</p><p>maxEndTime: {maxEndTimes[fromLane][toLane]}</p></div></td>);\r\n                                        }\r\n                                    })\r\n                                }</tr>);\r\n                        }\r\n                    )}\r\n                    </tbody>\r\n                </table>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default Drawer;","export default class Downloader{\r\n    static download(_url){\r\n        return new Promise((resolve,reject) => {\r\n            try {\r\n\r\n\r\n                fetch(_url)\r\n                    .then(function (response) {\r\n                        resolve(response.text());\r\n                    })\r\n                    .catch(err => {\r\n                        console.error(err);\r\n                        reject(err)\r\n                    });\r\n            }catch (e) {\r\n                console.error(_url);\r\n            }\r\n        });\r\n    }\r\n}\r\n","import n3 from 'n3';\r\n\r\nexport default class Helper{\r\n    static parseAndStoreQuads(_doc) {\r\n        return new Promise(resolve => {\r\n            const parser = new n3.Parser();\r\n            const store = new n3.Store();\r\n            parser.parse(_doc, (error, quad, prefixes) => {\r\n                if (quad)\r\n                    store.addQuad(quad);\r\n                else\r\n                    return resolve({\"store\": store, \"prefixes\": prefixes});\r\n            });\r\n        })\r\n    }\r\n\r\n    static writeN3Store(store, prefixes){\r\n        return new Promise(async (resolve) => {\r\n            const writer = new n3.Writer({ \"prefixes\": prefixes});\r\n            for(let quad of store.getQuads()){\r\n                writer.addQuad(quad);\r\n            }\r\n\r\n            await writer.end((error, result) => {resolve(result)});\r\n        });\r\n    }\r\n\r\n    static splitDateInParts(timeDate){\r\n        let result = {};\r\n        let toDate = new Date(timeDate);\r\n        result[\"hour\"] = toDate.getUTCHours();\r\n        result[\"month\"] = toDate.getUTCMonth();\r\n        result[\"minute\"] = toDate.getUTCMinutes();\r\n        result[\"day\"] = toDate.getUTCDay();    //0 == sunday\r\n        result[\"year\"] = toDate.getUTCFullYear();\r\n        return result;\r\n    }\r\n}","import n3 from 'n3';\r\nimport Helper from './Helper.js';\r\nconst { DataFactory } = n3;\r\nconst { namedNode } = DataFactory;\r\n\r\nexport default class FragmentHandler {\r\n    static async handleFragment(fragment) {\r\n        let returnObject = {};\r\n\r\n        let signalGroups = [];\r\n        let {store, prefixes} = await Helper.parseAndStoreQuads(fragment);\r\n\r\n        await store.getQuads(null, namedNode('http://www.w3.org/2000/01/rdf-schema#type'), namedNode('https://w3id.org/opentrafficlights#Signalgroup')).forEach(quad => {\r\n            signalGroups.push(quad.subject.value);\r\n        });\r\n\r\n        //only use most recent observation\r\n        let observation = await store.getQuads(null, namedNode('http://www.w3.org/ns/prov#generatedAtTime'), null).sort(function (a, b) {\r\n                a = new Date(a.object.value).getTime();\r\n                b = new Date(b.object.value).getTime();\r\n\r\n                return a > b ? -1 : a < b ? 1 : 0;\r\n            }\r\n        )[0];\r\n        if(observation){\r\n            let generatedAtTime = observation.object.value;\r\n\r\n            signalGroups.forEach((signalGroup) => {\r\n                let signalState = store.getQuads(namedNode(signalGroup), namedNode('https://w3id.org/opentrafficlights#signalState'), null, observation.subject)[0];\r\n                if(signalState) {\r\n                    let minEndTime = store.getQuads(signalState.object, namedNode('https://w3id.org/opentrafficlights#minEndTime'), null, observation.subject)[0].object.value;\r\n                    let maxEndTime = store.getQuads(signalState.object, namedNode('https://w3id.org/opentrafficlights#maxEndTime'), null, observation.subject)[0].object.value;\r\n                    let signalPhase = store.getQuads(signalState.object, namedNode('https://w3id.org/opentrafficlights#signalPhase'), null, observation.subject)[0].object.value;\r\n                    let likelyTime = undefined;\r\n                    try{\r\n                        likelyTime = store.getQuads(signalState.object, namedNode('https://w3id.org/opentrafficlights#likelyTime'), null, observation.subject)[0].object.value;\r\n                    }\r\n                    catch (e) {\r\n                        //TODO: clean!\r\n                        console.log(\"no likelyTime\");\r\n                    }\r\n\r\n                    if(!returnObject[signalGroup]){\r\n                        returnObject[signalGroup] = {};\r\n                    }\r\n                    returnObject[signalGroup] = {\r\n                        \"generatedAtTime\": generatedAtTime && new Date(generatedAtTime),\r\n                        \"minEndTime\": minEndTime && new Date(minEndTime),\r\n                        \"maxEndTime\": maxEndTime && new Date(maxEndTime),\r\n                        \"signalPhase\": signalPhase,\r\n                        \"likelyTime\": likelyTime && new Date(likelyTime)\r\n                    }\r\n\r\n                }\r\n            });\r\n        }\r\n\r\n        return returnObject;\r\n    }\r\n}","import React, { Component } from 'react';\r\nimport Downloader from '../Parser/Downloader.js';\r\nimport FragmentHandler from '../Parser/FragmentHandler.js';\r\n\r\nexport default class SignalGroupDrawer extends Component{\r\n    constructor(props){\r\n        super(props);\r\n        this.DATASET_URL = 'http://localhost:8080/latest';\r\n\r\n        this.state = {\r\n            data: {}\r\n        };\r\n    }\r\n\r\n    componentDidMount() {\r\n        setInterval(() => {\r\n            Downloader.download(this.DATASET_URL).then((fragment) => {\r\n                FragmentHandler.handleFragment(fragment).then((returnObject) => {\r\n                    console.log(\"download success\");\r\n                    this.setState({\r\n                        data: returnObject,\r\n                    });\r\n                })\r\n            }).catch(() => {\r\n                    console.log(\"download error\");\r\n                }\r\n            );\r\n        }, 1000);\r\n    }\r\n\r\n    render(){\r\n        let { data } = this.state;\r\n        console.log(\"render\");\r\n        return (\r\n            <div className=\"Drawer\">\r\n                <table>\r\n                    <thead>\r\n                    <tr>\r\n                        <th>SignalGroup</th>\r\n                        <th>SignalPhase</th>\r\n                    </tr>\r\n                    </thead>\r\n                    <tbody>\r\n                    {Object.keys(data).map((signalGroup) => {\r\n                        return (\r\n                            <tr>\r\n                                <td>signalGroup: {signalGroup}</td>\r\n                                <td>generatedAtTime: {data[signalGroup] ? data[signalGroup].generatedAtTime : \"no data\"}</td>\r\n                                <td>minEndTime: {data[signalGroup] ? data[signalGroup].minEndTime : \"no data\"}</td>\r\n                                <td>maxEndTime: {data[signalGroup] ? data[signalGroup].maxEndTime : \"no data\"}</td>\r\n                                <td>signalPhase: {data[signalGroup] ? data[signalGroup].signalPhase : \"no data\"}</td>\r\n                                <td>likelyTime: {data[signalGroup] ? data[signalGroup].likelyTime : \"no data\"}</td>\r\n                            </tr>\r\n                        );\r\n                    })}\r\n                    </tbody>\r\n                </table>\r\n            </div>\r\n        )\r\n    }\r\n}","import React, { Component } from 'react';\r\nimport './Countdown.css';\r\n\r\nexport default class Countdown extends Component{\r\n    render(){\r\n        let {count, color} = this.props;\r\n        if(count === undefined){\r\n            count = \"X\";\r\n        }\r\n        let textColor = \"black\";\r\n        if(color === 0){\r\n            textColor = \"orange\";\r\n        }\r\n        if(color === 3){\r\n            textColor = \"red\";\r\n        }\r\n        if(color === 6){\r\n            textColor = \"green\";\r\n        }\r\n        return (\r\n            <div className=\"Countdown\">\r\n                <div className=\"Countdown_value\" style={{color: textColor}}>{count}</div>\r\n            </div>\r\n        )\r\n    }\r\n}","import React, { Component } from 'react';\r\nimport \"./MinMaxTable.css\"\r\n\r\nexport default class MinMaxTable extends Component{\r\n    render(){\r\n        let {min, max} = this.props;\r\n        if(min === undefined){\r\n            min = \"X\";\r\n        }\r\n        if(max === undefined){\r\n            max = \"X\";\r\n        }\r\n        return (\r\n            <div className=\"MinMaxTable\" >\r\n                <div className=\"MinMaxTable_minimum_box\">\r\n                    <div className=\"MinMaxTable_minimum_title\">Minimum</div><div className=\"MinMaxTable_minimum_value\">{min}</div>\r\n                </div>\r\n                <div className=\"MinMaxTable_maximum_box\">\r\n                    <div className=\"MinMaxTable_maximum_title\">Maximum</div><div className=\"MinMaxTable_maximum_value\">{max}</div>\r\n                </div>\r\n            </div>\r\n        )\r\n    }\r\n}","import React, { Component } from 'react';\r\nimport 'react-vis/dist/style.css';\r\nimport {XYPlot, FlexibleXYPlot, VerticalBarSeries,LineSeries, LineMarkSeries, HorizontalGridLines, XAxis, YAxis} from 'react-vis';\r\nimport './Graph.css';\r\n\r\nclass LineChart extends Component {\r\n\r\n    render() {\r\n        const {minData, maxData, likelyData, title} = this.props;\r\n        return (\r\n            <div className=\"BarChart\">\r\n                <p>{title}</p>\r\n                <XYPlot height={300} width={800} xType={\"time\"}>\r\n                    <HorizontalGridLines />\r\n                    <LineSeries data={minData} barWidth={0.95} color={\"green\"}/>\r\n                    <LineSeries data={maxData} barWidth={0.95} color={\"red\"}/>\r\n                    <LineSeries data={likelyData} barWidth={0.95} color={\"blue\"}/>\r\n                    <XAxis title={\"Time\"}/>\r\n                    <YAxis title={\"Duration (s)\"}/>\r\n                </XYPlot>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default LineChart;","import React, { Component } from 'react';\r\nimport 'react-vis/dist/style.css';\r\nimport {XYPlot, FlexibleXYPlot, VerticalBarSeries,LineSeries, LabelSeries, HorizontalGridLines, XAxis, YAxis} from 'react-vis';\r\nimport './Graph.css';\r\n\r\nclass PhaseColorGraph extends Component {\r\n\r\n    render() {\r\n        const {red, orange, green, title} = this.props;\r\n        return (\r\n            <div className=\"PhaseColorGraph\">\r\n                <p>{title}</p>\r\n                <XYPlot height={100} width={800} xType={\"time\"}>\r\n                    <LineSeries data={red} color={\"red\"}/>\r\n                    <LineSeries data={orange} color={\"orange\"}/>\r\n                    <LineSeries data={green} color={\"green\"}/>\r\n                    <XAxis title={\"Time\"}/>\r\n                    <YAxis title={\"Color\"} style={{\r\n                         // line: {stroke: 'none'},\r\n                        ticks: {stroke: 'none'},\r\n                         text: {stroke: 'none', fill: 'none'}\r\n                    }}/>\r\n                </XYPlot>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default PhaseColorGraph;","import React from 'react';\r\n\r\nlet Dropdown = (props) =>{\r\n    let {activeValue, options, onChange} = props;\r\n    return (\r\n        <select value={activeValue} onChange={(event) => onChange(event.target.value)}>\r\n            {Object.keys(options).map((key)=> {\r\n                return <option value={key} id={key}>{key}</option>\r\n            })}\r\n        </select>\r\n    );\r\n};\r\nexport default Dropdown;","import React, { Component } from 'react';\r\nimport \"./ErrorBox.css\";\r\n\r\nexport default class ErrorBox extends Component{\r\n    constructor(props){\r\n        super(props);\r\n        this.state = {\r\n            show: true\r\n        };\r\n        this.onClick = this.onClick.bind(this);\r\n    }\r\n\r\n    onClick(){\r\n        this.setState({\r\n            show: false\r\n        });\r\n    }\r\n\r\n    render(){\r\n        let {show} = this.state;\r\n        if(show !== false){\r\n            return (\r\n                <div className=\"ErrorBox_alert\">\r\n                    <span className=\"ErrorBox_alertCloseBtn\" onClick={this.onClick}>&times;</span>\r\n                    {this.props.message}\r\n                </div>)\r\n        }\r\n        else{\r\n            return null;\r\n        }\r\n    }\r\n}\r\n","import n3 from 'n3';\r\nimport Helper from '../../Parser/Helper.js';\r\nconst { DataFactory } = n3;\r\nconst { namedNode } = DataFactory;\r\n\r\n//expect recieved fragments to be in ordered by time, increasing (oldest first)\r\nexport default class FragmentParser{\r\n    constructor(showGeneratedAtTimeErrors = true, showPhaseErrors = true){\r\n        this.phaseStart = {}; //om de start van een fase te detecteren, voor iedere observatie\r\n        this.lastPhase = {}; //om de laatst tegengekomen fase op te slaan, voor iedere observatie\r\n        this.lastMaxEndTime = {};   //als maxEndTime van de vorige meting kleiner is dan van de huidige, en de fase is niet aangepast, dan ontbreken waarschijnlijk enkele fragmenten\r\n        this.lastMinEndTime = {};\r\n        this.lastObservation = {};\r\n        this.maxDidIncrease = {};\r\n        this.showGeneratedAtTimeErrors = showGeneratedAtTimeErrors;\r\n        this.showPhaseErrors = showPhaseErrors;\r\n\r\n        //debug\r\n        this.startUpObservations = 0;   //count observations needed for startup at start or after reset\r\n        this.generatedBeforeLastErrors = 0; //count if generatedAtTime > last observation generatedAtTime\r\n        this.onSamePhaseResets = 0; //count samePhase resets\r\n        this.onPhaseChangeResets = 0;   //count phaseChange resets\r\n        this.observationSameAsLast = 0; //count when generatedAtTime is same as last observed generatedAtTime\r\n\r\n        this.realStartUpObservations = 0;   //count observations needed for startup\r\n        this.realStartUp = {};  //is true if startup completed\r\n    }\r\n\r\n    printDebugInfo(){\r\n        console.log(\"<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>\");\r\n        console.log(\"   FragmentParser debug info:\");\r\n        console.log(\"    - startUpObservations (reset included): \"+this.startUpObservations);\r\n        console.log(\"    - realStartUpObservations (startup only): \"+this.realStartUpObservations);\r\n        console.log(\"    - generatedBeforeLastErrors: \"+this.generatedBeforeLastErrors);\r\n        console.log(\"    - observationSameAsLast: \"+this.observationSameAsLast);\r\n        console.log(\"    - onSamePhaseResets: \"+this.onSamePhaseResets);\r\n        console.log(\"    - onPhaseChangeResets: \"+this.onPhaseChangeResets);\r\n        console.log(\"<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>\");\r\n    }\r\n\r\n    static _initReturnObject(){\r\n        return {\r\n            \"signalGroup\": undefined,   //signalGroup of current observation\r\n            \"signalPhase\": undefined,   //signalPhase of current observation\r\n            \"signalState\": undefined,   //signalState quad (not used)\r\n            \"generatedAtTime\": undefined,   //generation time of current observation\r\n            \"minEndTime\": undefined,    //minEndTime defined in current observation\r\n            \"maxEndTime\": undefined,    //maxEndTime defined in current observation\r\n            \"observation\": undefined,   //observation quad (not used)\r\n            \"store\": undefined, //n3 store object\r\n            \"prefixes\": undefined,  //prefixes in trig rdf fragment\r\n            \"phaseStart\": undefined,    //start of phase of current observation\r\n            \"lastPhaseStart\": undefined,    //start of phase of last observation\r\n            \"lastPhase\": undefined,  //phase of last observation\r\n            \"maxDidIncrease\": undefined //maxEndTime did increase for same phase\r\n        };\r\n    }\r\n\r\n    static _setReturnObject(returnObject, signalGroup, signalPhase, signalState, generatedAtTime, minEndTime, maxEndTime, observation, store, prefixes, phaseStart, lastPhaseStart, lastPhase, maxDidIncrease){\r\n        returnObject[\"signalGroup\"] = signalGroup;\r\n        returnObject[\"signalPhase\"] = signalPhase;\r\n        returnObject[\"signalState\"] = signalState;\r\n        returnObject[\"generatedAtTime\"] = generatedAtTime;\r\n        returnObject[\"minEndTime\"] = minEndTime;\r\n        returnObject[\"maxEndTime\"] = maxEndTime;\r\n        returnObject[\"observation\"] = observation;\r\n        returnObject[\"store\"] = store;\r\n        returnObject[\"prefixes\"] = prefixes;\r\n        returnObject[\"phaseStart\"] = phaseStart;\r\n        returnObject[\"lastPhaseStart\"] = lastPhaseStart;\r\n        returnObject[\"lastPhase\"] = lastPhase;\r\n        returnObject[\"maxDidIncrease\"] = maxDidIncrease;\r\n    };\r\n\r\n    //TODO: remove file param -> debugging\r\n    async handleFragment(fragment, file, onPhaseChange, onSamePhase, onObservationBeforeValidityCheck, afterHandle, onFragmentError){\r\n        let returnObject = FragmentParser._initReturnObject();\r\n        let { store, prefixes } = await Helper.parseAndStoreQuads(fragment);\r\n\r\n        let signalGroups = [];\r\n\r\n        await store.getQuads(null, namedNode('http://www.w3.org/2000/01/rdf-schema#type'), namedNode('https://w3id.org/opentrafficlights#Signalgroup')).forEach(quad => {\r\n            signalGroups.push(quad.subject.value);\r\n            if(!this.phaseStart[quad.subject.value]){\r\n                this.phaseStart[quad.subject.value] = -1;\r\n            }\r\n            if(!this.lastPhase[quad.subject.value]){\r\n                this.lastPhase[quad.subject.value] = -1;\r\n            }\r\n            if(!this.lastMaxEndTime[quad.subject.value]){\r\n                this.lastMaxEndTime[quad.subject.value] = -1;\r\n            }\r\n            if(!this.lastMinEndTime[quad.subject.value]){\r\n                this.lastMinEndTime[quad.subject.value] = -1;\r\n            }\r\n            if(!this.lastObservation[quad.subject.value]){\r\n                this.lastObservation[quad.subject.value] = undefined;\r\n            }\r\n            if(!this.maxDidIncrease[quad.subject.value]){\r\n                this.maxDidIncrease[quad.subject.value] = {};\r\n            }\r\n            if(!this.realStartUp[quad.subject.value]){\r\n                this.realStartUp[quad.subject.value] = 0;\r\n            }\r\n        });\r\n\r\n        //als de eerste observatie in een fragment niet overeenkomt met zijn naam, als die een bestandsnaam heeft, dan is het fragment in de historicfilesystemreader ingelezen niet geldig,\r\n        //want dan kan de chronologische ordening volgens bestandsnaam niet worden gegarandeerd.\r\n        let isFragmentValid = true;\r\n        if(file){\r\n            let firstObservation = await store.getQuads(null, namedNode('http://www.w3.org/ns/prov#generatedAtTime'), null).sort(function(a, b) {\r\n                    a = new Date(a.object.value).getTime();\r\n                    b = new Date(b.object.value).getTime();\r\n\r\n                    return a<b ? -1 : a>b ? 1 : 0;\r\n                }\r\n            )[0];\r\n            if(!firstObservation){\r\n                isFragmentValid = false;\r\n            }\r\n            else{\r\n                let firstObservationName = \"fragment_\" + (firstObservation.object.value).replace(/\\:/g,\"_\").replace(/\\./g,\"_\") + \".trig\";\r\n                if( firstObservationName !== file){\r\n                    console.log(\"\\x1b[31m\",\"Filename is not correct: \"+file + \", first observation: \"+firstObservationName,\"\\x1b[0m\");\r\n                    isFragmentValid = false;\r\n                }\r\n            }\r\n        }\r\n        if(isFragmentValid) {\r\n            //overlopen van alle observaties in een fragment, gesorteerd met oudste eerst\r\n            await store.getQuads(null, namedNode('http://www.w3.org/ns/prov#generatedAtTime'), null).sort(function (a, b) {\r\n                    a = new Date(a.object.value).getTime();\r\n                    b = new Date(b.object.value).getTime();\r\n\r\n                    return a < b ? -1 : a > b ? 1 : 0;\r\n                }\r\n            ).forEach((observation) => {\r\n                let generatedAtTime = observation.object.value;\r\n\r\n                signalGroups.forEach(signalGroup => {\r\n                    let error = 0;\r\n                    if (this.lastObservation[signalGroup]) {\r\n                        if (new Date(this.lastObservation[signalGroup]).getTime() > new Date(generatedAtTime).getTime()) {\r\n                            this.showGeneratedAtTimeErrors && console.log(file + \" : Observation: \" + generatedAtTime + \" signalGroup: \" + signalGroup + \" | last observation bigger than new: \" + this.lastObservation[signalGroup] + \" - \" + generatedAtTime);\r\n                            this.generatedBeforeLastErrors++;\r\n                            error = 1;\r\n                        }\r\n\r\n                        //latest fragments can contain the same observation, previous fragments should not contain duplicate\r\n                        //no code breaking bug, but can be nice to know -> logged\r\n                        if (generatedAtTime === this.lastObservation[signalGroup]) {\r\n                            this.showGeneratedAtTimeErrors && console.log(\"generatedAtTime \" + generatedAtTime + \" is same as last \" + this.lastObservation[signalGroup] + \" sg: \" + signalGroup);\r\n                            this.observationSameAsLast++;\r\n                        }\r\n                    }\r\n\r\n                    let signalState = store.getQuads(namedNode(signalGroup), namedNode('https://w3id.org/opentrafficlights#signalState'), null, observation.subject)[0]; //zit altijd 1 of geen in, als de signalstate is aangepast op generatedAtTime voor de opgegeven signalgroup\r\n                    if (signalState) {\r\n                        let minEndTime = store.getQuads(signalState.object, namedNode('https://w3id.org/opentrafficlights#minEndTime'), null, observation.subject)[0].object.value;\r\n                        let maxEndTime = store.getQuads(signalState.object, namedNode('https://w3id.org/opentrafficlights#maxEndTime'), null, observation.subject)[0].object.value;\r\n                        let signalPhase = store.getQuads(signalState.object, namedNode('https://w3id.org/opentrafficlights#signalPhase'), null, observation.subject)[0].object.value;\r\n\r\n                        //debug\r\n                        if (generatedAtTime > maxEndTime) {\r\n                            console.log(\"fragment contains observation generated after maxEndTime: \" + file);\r\n                        }\r\n\r\n                        if (this.phaseStart[signalGroup] !== -1 && this.lastPhase[signalGroup] !== -1) {\r\n                            if (this.realStartUp[signalGroup] === 0) {    //TODO: debug info\r\n                                this.realStartUp[signalGroup] = 1;   //debug info\r\n                            }\r\n                            if (this.lastPhase[signalGroup] !== signalPhase) {\r\n                                //phase change\r\n                                if (onObservationBeforeValidityCheck) { //dangerous, not checked validity of observation before phase change, data could be invalid (see checks)\r\n                                    FragmentParser._setReturnObject(returnObject, signalGroup, signalPhase, signalState, generatedAtTime, minEndTime, maxEndTime, observation, store, prefixes, generatedAtTime, this.phaseStart[signalGroup], this.lastPhase[signalGroup], this.maxDidIncrease[signalGroup][signalPhase]);\r\n                                    onObservationBeforeValidityCheck(returnObject);\r\n                                }\r\n                                if(!error) {\r\n                                    //kruispunt publiceerd om de 200 ms, observer neemt waar bij aanpassing aan fase. Als fase gaat aanpassen (maxEndTime), gaat hij nog een bericht sturen\r\n                                    //dat aangeeft dat het nog niet is aangepast, maar NU gaat aanpassen. De observer neemt pas het volgende bericht dat weldegelijk is aangepast weer,\r\n                                    //en dat bericht komt dus 200 ms later dan het werkelijke moment waarop de aanpassing ging gebeuren.\r\n                                    //vandaar de 200 ms check\r\n                                    //soms is generatedAtTime-200ms net 1 ms later dan lastMaxEndTime\r\n                                    //nog 1 ms extra rekenen\r\n                                    //soms ook net wat langer (2 - 5 ms)\r\n                                    //bij min hoeft niet worden aangepast, want komt zelden voor (anders ook +205 bij lastMinEndTime)\r\n                                    if (new Date(generatedAtTime).getTime() > new Date(this.lastObservation[signalGroup]).getTime()+5000 &&\r\n                                        ((this.lastMaxEndTime[signalGroup] !== -1 && new Date(generatedAtTime).getTime() > new Date(this.lastMaxEndTime[signalGroup]).getTime() + 210)\r\n                                            || (this.lastMinEndTime[signalGroup] !== -1 && generatedAtTime < this.lastMinEndTime[signalGroup]))\r\n                                    ) {\r\n                                        //phase can't end after maxEndTime and before minEndTime, if this is the case, it is not the same phase or an error occurred in the data\r\n                                        this.lastPhase[signalGroup] = -1;   //reset\r\n                                        this.phaseStart[signalGroup] = -1;\r\n                                        this.onPhaseChangeResets++;\r\n                                        this.showPhaseErrors && console.log(\"onPhaseChangeError: \" + file + \" generatedAtTime: \" + generatedAtTime + \" maxEndTime: \" + maxEndTime + \" lastMaxEndTime: \" + this.lastMaxEndTime[signalGroup] + \" lastMinEndTime: \" + this.lastMinEndTime[signalGroup] + \" last observation (gereratedAtTime): \" + this.lastObservation[signalGroup]);\r\n                                        if (onFragmentError) {\r\n                                            onFragmentError(signalGroup);\r\n                                        }\r\n                                        this.lastMaxEndTime[signalGroup] = -1;  //maximale eindtijd laatste fragment\r\n                                        this.lastMinEndTime[signalGroup] = -1; //minimale eindtijd laatste fragment\r\n                                    } else {\r\n                                        if (onPhaseChange) {\r\n                                            FragmentParser._setReturnObject(returnObject, signalGroup, signalPhase, signalState, generatedAtTime, minEndTime, maxEndTime, observation, store, prefixes, generatedAtTime, this.phaseStart[signalGroup], this.lastPhase[signalGroup], this.maxDidIncrease[signalGroup][signalPhase]);\r\n                                            onPhaseChange(returnObject);\r\n                                        }\r\n\r\n                                        //prepare for next phase\r\n                                        this.lastPhase[signalGroup] = signalPhase;\r\n                                        this.phaseStart[signalGroup] = generatedAtTime;\r\n\r\n                                        this.lastMaxEndTime[signalGroup] = maxEndTime;  //maximale eindtijd laatste fragment\r\n                                        this.lastMinEndTime[signalGroup] = minEndTime; //minimale eindtijd laatste fragment\r\n                                    }\r\n                                }\r\n                            } else {\r\n                                //same phase\r\n                                if (onObservationBeforeValidityCheck) { //dangerous, not checked validity of observation before phase change, data could be invalid (see checks)\r\n                                    FragmentParser._setReturnObject(returnObject, signalGroup, signalPhase, signalState, generatedAtTime, minEndTime, maxEndTime, observation, store, prefixes, this.phaseStart[signalGroup], this.phaseStart[signalGroup], this.lastPhase[signalGroup], this.maxDidIncrease[signalGroup][signalPhase]);\r\n                                    onObservationBeforeValidityCheck(returnObject);\r\n                                }\r\n                                if(!error) {\r\n                                    //lodi.ilabt.imec.be onnauwkeurige data -> soms meerdere observaties max verhoogt\r\n                                    //als observatie op zelfde moment is gemaakt, kan die eens met en grotere maxEndTime worden ingelezen, als die dan eerst wordt verwerkt is de voorwaarde\r\n                                    //niet meer voldaan en is er mogelijks een gat, terwijl dit niet echt kan, want op hetzelfde moment aangemaakt\r\n                                    //als zelfde generatedAtTime als vorige -> niet controleren op gat\r\n                                    //(zou ook gewoon kunnen sorteren op max en min etc, maar meer computationeel werk)\r\n                                    if (new Date(generatedAtTime).getTime() > new Date(this.lastObservation[signalGroup]).getTime()+5000 &&\r\n                                        ((this.lastMaxEndTime[signalGroup] !== -1 && new Date(maxEndTime).getTime() > new Date(this.lastMaxEndTime[signalGroup]).getTime() + 1005)\r\n                                            || (this.lastMinEndTime[signalGroup] !== -1 && new Date(minEndTime).getTime() + 1005 < new Date(this.lastMinEndTime[signalGroup]).getTime()))\r\n                                    ) {\r\n                                        //maxEndTime can not increase for same phase, minEndTime can not decrease, if this is the case, it is not the same phase or an error occurred in the data\r\n                                        //if id does increase and it is correct, the time between observations can not be greater than 5 seconds (tolerance)\r\n                                        this.lastPhase[signalGroup] = -1;   //reset\r\n                                        this.phaseStart[signalGroup] = -1;\r\n                                        this.showPhaseErrors && console.log(\"onSamePhaseError: \" + file + \" generatedAtTime: \" + generatedAtTime + \" maxEndTime: \" + maxEndTime + \" lastMaxEndTime: \" + this.lastMaxEndTime[signalGroup] + \" minEndTime: \" + minEndTime + \" lastMinEndTime: \" + this.lastMinEndTime[signalGroup] + \" last observation (gereratedAtTime): \" + this.lastObservation[signalGroup]);\r\n                                        this.onSamePhaseResets++;\r\n\r\n                                        if (onFragmentError) {\r\n                                            onFragmentError(signalGroup);\r\n                                        }\r\n                                        this.lastMaxEndTime[signalGroup] = -1;  //maximale eindtijd laatste fragment\r\n                                        this.lastMinEndTime[signalGroup] = -1; //minimale eindtijd laatste fragment\r\n                                    } else {\r\n                                        if(this.maxDidIncrease[signalGroup][signalPhase] !== true){ //see increase in maxEndTime only if higher than 1005 ms (tolerance)\r\n                                            this.maxDidIncrease[signalGroup][signalPhase] = new Date(maxEndTime).getTime() > new Date(this.lastMaxEndTime[signalGroup]).getTime() + 1005;\r\n                                        }\r\n                                        if (onSamePhase) {\r\n                                            FragmentParser._setReturnObject(returnObject, signalGroup, signalPhase, signalState, generatedAtTime, minEndTime, maxEndTime, observation, store, prefixes, this.phaseStart[signalGroup], this.phaseStart[signalGroup], this.lastPhase[signalGroup], this.maxDidIncrease[signalGroup][signalPhase]);\r\n                                            onSamePhase(returnObject);\r\n                                        }\r\n                                        this.lastMaxEndTime[signalGroup] = maxEndTime;  //maximale eindtijd laatste fragment\r\n                                        this.lastMinEndTime[signalGroup] = minEndTime; //minimale eindtijd laatste fragment\r\n                                    }\r\n                                }\r\n                            }\r\n                        } else {\r\n                            if(!error) {\r\n                                if (this.realStartUp[signalGroup] === 0) {    //TODO: debug info\r\n                                    this.realStartUpObservations++;\r\n                                }\r\n                                this.startUpObservations++;\r\n                                if (this.phaseStart[signalGroup] === -1 && this.lastPhase[signalGroup] === -1) {\r\n                                    this.lastPhase[signalGroup] = signalPhase;\r\n                                } else if (this.lastPhase[signalGroup] !== signalPhase) {\r\n                                    this.lastPhase[signalGroup] = signalPhase;\r\n                                    this.phaseStart[signalGroup] = generatedAtTime;\r\n                                }\r\n                                this.lastMaxEndTime[signalGroup] = maxEndTime;  //maximale eindtijd laatste fragment\r\n                                this.lastMinEndTime[signalGroup] = minEndTime; //minimale eindtijd laatste fragment\r\n                            }\r\n                        }\r\n                        // this.lastMaxEndTime[signalGroup] = maxEndTime;  //maximale eindtijd laatste fragment\r\n                        // this.lastMinEndTime[signalGroup] = minEndTime; //minimale eindtijd laatste fragment\r\n                        if(!error){\r\n                            this.lastObservation[signalGroup] = generatedAtTime;\r\n                        }\r\n                    }\r\n\r\n                });\r\n\r\n            });\r\n        }\r\n        if(afterHandle){\r\n            FragmentParser._setReturnObject(returnObject, undefined, undefined, undefined, undefined, undefined, undefined, undefined, store, prefixes, undefined, undefined, undefined, undefined);\r\n            afterHandle(returnObject);\r\n        }\r\n    }\r\n\r\n}","export default class PredictionCalculator{\r\n    static calculateMeanDuration(frequencyDistribution){\r\n        let weightedSum = 0;\r\n        let count = 0;\r\n        Object.keys(frequencyDistribution).forEach((duration) => {\r\n            count+=frequencyDistribution[duration];\r\n            weightedSum = weightedSum + duration * frequencyDistribution[duration];\r\n        });\r\n        if(count === 0){\r\n            return undefined;\r\n        }\r\n        else {\r\n            return Math.round(weightedSum / count); //TODO: kan delen door 0 -> NaN\r\n        }\r\n    }\r\n\r\n    static calculateMedianDuration(frequencyDistribution){\r\n        let count = 0;\r\n        Object.keys(frequencyDistribution).forEach((duration) => {\r\n            count+=frequencyDistribution[duration];\r\n        });\r\n        let runner = 0;\r\n        let median = undefined;\r\n        let i = 0;\r\n        let list = Object.keys(frequencyDistribution);\r\n        while(median === undefined && i<list.length){\r\n            if(count/2 > runner && count/2 <= runner+frequencyDistribution[list[i]]){\r\n                median = list[i];\r\n            }\r\n            runner+=frequencyDistribution[list[i]];\r\n            i++;\r\n        }\r\n        if(count === 0){\r\n            return undefined;\r\n        }\r\n        else {\r\n            return parseInt(median, 10);\r\n        }\r\n    }\r\n\r\n    //give value where {part} is smaller than value or equal, 1-{part} is bigger\r\n    static calculatePartDuration(frequencyDistribution, part){\r\n        let count = 0;\r\n        Object.keys(frequencyDistribution).forEach((duration) => {\r\n            count+=frequencyDistribution[duration];\r\n        });\r\n        let runner = 0;\r\n        let result = undefined;\r\n        let i = 0;\r\n        let list = Object.keys(frequencyDistribution);\r\n        while(result === undefined && i<list.length){\r\n            if(count*part > runner && count*part <= runner+frequencyDistribution[list[i]]){\r\n                result = list[i];\r\n            }\r\n            runner+=frequencyDistribution[list[i]];\r\n            i++;\r\n        }\r\n        if(count === 0){\r\n            return undefined;\r\n        }\r\n        else {\r\n            return parseInt(result, 10);\r\n        }\r\n    }\r\n\r\n    static calculateMostCommonDuration(frequencyDistribution){\r\n        let result = undefined;\r\n        Object.keys(frequencyDistribution).forEach((duration) => {\r\n            if(result === undefined){\r\n                result = duration;\r\n            }\r\n            else if(frequencyDistribution[duration] > frequencyDistribution[result]){\r\n                result = duration;\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n\r\n    \r\n}","import PredictionCalculator from './PredictionCalculator.js';\r\n\r\n//TODO: als min === max, kan al terug geven voordat moet worden gerekend\r\n//TODO: remove phaseDuration param -> debugging\r\n//TODO: confidence -> vb %dat de predictedValue wel degelijk voorkwam tov alle voorkomens (die ook nog kunnen voorkomen, dus in futureDistribution)\r\nexport default class PredictionManager{\r\n    //simple median value\r\n    static predictLikelyTime(signalGroup, signalPhase, generatedAtTime, minEndTime, maxEndTime, phaseStart, distribution, predictionCalculatorFunction, maxDidIncrease){\r\n        try {\r\n            if (distribution && Object.keys(distribution).length > 0) {\r\n                let result = new Date(phaseStart);\r\n                let observationTime = new Date(generatedAtTime);\r\n\r\n                let elapsedDuration = (observationTime.getTime() - result.getTime()) / 1000;\r\n                let futureDistribution = {};\r\n                Object.keys(distribution).forEach((key) => {    //calculate mean only over future durations, not past\r\n                    if (key >= elapsedDuration) {  //TODO: should > or >= ?\r\n                        futureDistribution[key] = distribution[key];\r\n                    }\r\n                });\r\n                //if futureDistribution = empty -> predictedDuration = undefined\r\n                let likelyTime = undefined;\r\n\r\n                let predictedDuration = predictionCalculatorFunction(distribution);\r\n                if(predictedDuration < elapsedDuration){\r\n                    predictedDuration = predictionCalculatorFunction(futureDistribution);\r\n                }\r\n                // let distributionSize = Helper.countObservationsInDistribution(distribution);\r\n                // console.log(\"size: \"+distributionSize);   //TODO: log\r\n                if(predictedDuration !== undefined){\r\n                    result.setTime(result.getTime() + predictedDuration * 1000);\r\n                    likelyTime = result.toISOString();\r\n                }\r\n                if (minEndTime && maxEndTime && minEndTime === maxEndTime) { //TODO: predict longer than max\r\n                    likelyTime = minEndTime;\r\n                } else if (likelyTime!== undefined && likelyTime < minEndTime) {\r\n                    likelyTime = minEndTime;\r\n                } else if (likelyTime !== undefined && !maxDidIncrease && likelyTime > maxEndTime ) {\r\n                    likelyTime = maxEndTime;\r\n                // } else if (likelyTime !== undefined && new Date(likelyTime).getTime() > new Date(maxEndTime).getTime()+210 && new Date(likelyTime).getTime() < new Date(maxEndTime).getTime() + 5000 ) {\r\n                //     likelyTime = maxEndTime;\r\n                }\r\n                //TODO: als geen prediction meer mogelijk, maar alle historische waarden liggen onder minEndTime -> minEndTime als prediction (en omgekeerd voor max)?\r\n                // if(likelyTime === undefined){\r\n                //     likelyTime = minEndTime;\r\n                // }\r\n\r\n                // if(signalGroup === \"https://opentrafficlights.org/id/signalgroup/K648/4\" && signalPhase === \"https://w3id.org/opentrafficlights/thesauri/signalphase/0\"){\r\n                //     console.log(\"----------------------------------------------------\");\r\n                //     console.log(futureDistribution);\r\n                //     console.log(distribution);\r\n                //     console.log(\"phaseStart: \"+phaseStart);\r\n                //     console.log(\"generatedAtTime: \"+generatedAtTime);\r\n                //     console.log(\"likelyTime: \"+likelyTime);\r\n                //     console.log(predictedDuration);\r\n                //     console.log((new Date(likelyTime).getTime()-new Date(generatedAtTime).getTime())/1000);\r\n                // }\r\n                return likelyTime;   //TODO: undefined likelyTime if prediction not possible\r\n            }\r\n        } catch (e) {\r\n            //console.log(e);\r\n        }\r\n    }\r\n\r\n    //next is same as previous\r\n    static predictLikelyTimeSamePrevious(lastPhaseDuration, signalGroup, signalPhase, minEndTime, maxEndTime, phaseStart){\r\n        try {\r\n            let result = new Date(phaseStart);\r\n            let likelyTime = undefined;\r\n            let predictedDuration = lastPhaseDuration;\r\n            if(predictedDuration !== undefined){\r\n                result.setTime(result.getTime() + predictedDuration * 1000);\r\n                likelyTime = result.toISOString();\r\n            }\r\n            if (minEndTime && maxEndTime && minEndTime === maxEndTime) { //TODO: min en max niet precies -> duration komt soms niet helemaal overeen (zie hieronder) -> voorspelling zit afwijking op!!!\r\n                likelyTime = minEndTime;\r\n            } else if (likelyTime!== undefined && likelyTime < minEndTime) {\r\n                likelyTime = minEndTime;\r\n            } else if (likelyTime !== undefined && likelyTime > maxEndTime) {\r\n                likelyTime = maxEndTime;\r\n            }\r\n            //TODO: als geen prediction meer mogelijk, maar alle historische waarden liggen onder minEndTime -> minEndTime als prediction (en omgekeerd voor max)?\r\n            return likelyTime;   //TODO: undefined likelyTime if prediction not possible\r\n\r\n        } catch (e) {\r\n            //console.log(e);\r\n        }\r\n    }\r\n\r\n    static predictLikelyTimeBasedOnPreviousPrediction(lastPhaseDuration, lastPredictedDuration, signalGroup, signalPhase, generatedAtTime, minEndTime, maxEndTime, phaseStart, distribution){\r\n        try {\r\n            if (distribution && Object.keys(distribution).length > 0) {\r\n                let result = new Date(phaseStart);\r\n                let observationTime = new Date(generatedAtTime);\r\n\r\n                let elapsedDuration = (observationTime.getTime() - result.getTime()) / 1000;\r\n                let futureDistribution = {};\r\n                Object.keys(distribution).forEach((key) => {    //calculate mean only over future durations, not past\r\n                    if (key > elapsedDuration) {  //TODO: should > or >= ?\r\n                        futureDistribution[key] = distribution[key];\r\n                    }\r\n                });\r\n                //if futureDistribution = empty -> predictedDuration = undefined\r\n                let likelyTime = undefined;\r\n                let lastPredictionRelativeError = (lastPredictedDuration-lastPhaseDuration)/lastPhaseDuration;\r\n                let predictedDuration = PredictionCalculator.calculatePartDuration(futureDistribution, lastPredictionRelativeError);\r\n                if(predictedDuration !== undefined){\r\n                    result.setTime(result.getTime() + predictedDuration * 1000);\r\n                    likelyTime = result.toISOString();\r\n                }\r\n                if (minEndTime && maxEndTime && minEndTime === maxEndTime) { //TODO: min en max niet precies -> duration komt soms niet helemaal overeen (zie hieronder) -> voorspelling zit afwijking op!!!\r\n                    likelyTime = minEndTime;\r\n                } else if (likelyTime!== undefined && likelyTime < minEndTime) {\r\n                    likelyTime = minEndTime;\r\n                } else if (likelyTime !== undefined && likelyTime > maxEndTime) {\r\n                    likelyTime = maxEndTime;\r\n                }\r\n                //TODO: als geen prediction meer mogelijk, maar alle historische waarden liggen onder minEndTime -> minEndTime als prediction (en omgekeerd voor max)?\r\n                return likelyTime;   //TODO: undefined likelyTime if prediction not possible\r\n            }\r\n        } catch (e) {\r\n            //console.log(e);\r\n        }\r\n    }\r\n}","export default class TimeFrequencyDistribution {\r\n    constructor(){\r\n        this.frequencyDistribution = {};\r\n    }\r\n\r\n    add(signalGroup, signalPhase, year, month, day, hour, minutes, duration){\r\n        if(!this.frequencyDistribution[signalGroup]){   //sg bestaat nog niet\r\n            this.frequencyDistribution[signalGroup] = {};\r\n        }\r\n        if(!this.frequencyDistribution[signalGroup][signalPhase]){\r\n            this.frequencyDistribution[signalGroup][signalPhase] = {};\r\n        }\r\n        if(!this.frequencyDistribution[signalGroup][signalPhase][year]){\r\n            this.frequencyDistribution[signalGroup][signalPhase][year] = {};\r\n        }\r\n        if(!this.frequencyDistribution[signalGroup][signalPhase][year][month]){\r\n            this.frequencyDistribution[signalGroup][signalPhase][year][month] = {};\r\n        }\r\n        if(!this.frequencyDistribution[signalGroup][signalPhase][year][month][day]){\r\n            this.frequencyDistribution[signalGroup][signalPhase][year][month][day] = {};\r\n        }\r\n        if(!this.frequencyDistribution[signalGroup][signalPhase][year][month][day][hour]){\r\n            this.frequencyDistribution[signalGroup][signalPhase][year][month][day][hour] = {};\r\n        }\r\n        if(!this.frequencyDistribution[signalGroup][signalPhase][year][month][day][hour][minutes]){\r\n            this.frequencyDistribution[signalGroup][signalPhase][year][month][day][hour][minutes] = {};\r\n        }\r\n        if(!this.frequencyDistribution[signalGroup][signalPhase][year][month][day][hour][minutes][duration]){\r\n            this.frequencyDistribution[signalGroup][signalPhase][year][month][day][hour][minutes][duration] = 1;\r\n        }\r\n        else {\r\n            this.frequencyDistribution[signalGroup][signalPhase][year][month][day][hour][minutes][duration]++;\r\n        }\r\n    }\r\n\r\n    getDistributions(){\r\n        return this.frequencyDistribution;\r\n    }\r\n\r\n    get(signalGroup, signalPhase, year, month, day, hour, minutes){\r\n        if(this.frequencyDistribution[signalGroup]\r\n            && this.frequencyDistribution[signalGroup][signalPhase]\r\n            && this.frequencyDistribution[signalGroup][signalPhase][year]\r\n            && this.frequencyDistribution[signalGroup][signalPhase][year][month]\r\n            && this.frequencyDistribution[signalGroup][signalPhase][year][month][day]\r\n            && this.frequencyDistribution[signalGroup][signalPhase][year][month][day][hour]\r\n            && this.frequencyDistribution[signalGroup][signalPhase][year][month][day][hour][minutes]\r\n        ){\r\n            return this.frequencyDistribution[signalGroup][signalPhase][year][month][day][hour][minutes];\r\n        }\r\n    }\r\n\r\n    createDistributionsCSV(){\r\n        let output = [];\r\n        Object.keys(this.frequencyDistribution).forEach((signalGroup) => {\r\n            Object.keys(this.frequencyDistribution[signalGroup]).forEach((signalPhase) => {\r\n                Object.keys(this.frequencyDistribution[signalGroup][signalPhase]).forEach((year) => {\r\n                    Object.keys(this.frequencyDistribution[signalGroup][signalPhase][year]).forEach((month) => {\r\n                        Object.keys(this.frequencyDistribution[signalGroup][signalPhase][year][month]).forEach((day) => {\r\n                            Object.keys(this.frequencyDistribution[signalGroup][signalPhase][year][month][day]).forEach((hour) => {\r\n                                Object.keys(this.frequencyDistribution[signalGroup][signalPhase][year][month][day][hour]).forEach((minutes) => {\r\n                                    let file = \"signalGroup,signalphase,year,month,day,hour,minutes,duration,amount\\n\";\r\n                                    Object.keys(this.frequencyDistribution[signalGroup][signalPhase][year][month][day][hour][minutes]).forEach((duration) => {\r\n                                        file += signalGroup+','+signalPhase+','+year+','+month+','+day+','+hour+','+minutes+','+duration+','+this.frequencyDistribution[signalGroup][signalPhase][year][month][day][hour][minutes][duration]+'\\n';\r\n                                    });\r\n                                    output.push(file);\r\n                                });\r\n                            });\r\n                        });\r\n                    });\r\n                });\r\n            });\r\n        });\r\n        return output;\r\n    }\r\n}","import n3 from 'n3';\r\nimport FragmentParser from \"./Readers/FragmentParser\";\r\nimport Helper from \"../Parser/Helper\";\r\nimport PredictionManager from \"./Predictor/PredictionManager\";\r\nimport DurationsManager from \"./Distributions/DurationsManager\";\r\nimport PredictionCalculator from \"./Predictor/PredictionCalculator\";\r\nimport TimeFrequencyDistribution from \"./Distributions/Types/TimeFrequencyDistribution\";\r\nconst { DataFactory } = n3;\r\nconst { namedNode, literal } = DataFactory;\r\n\r\nexport default class PredictionGenerator{\r\n    constructor() {\r\n        this.realTimeFragmentParser = new FragmentParser(false, false);\r\n        this.timeDistribution = new TimeFrequencyDistribution();\r\n    }\r\n\r\n    async generatePredictions(fragment) {\r\n        let result = \"\";\r\n        await this.realTimeFragmentParser.handleFragment(fragment, undefined,\r\n            (returnObject) => {\r\n                let { signalGroup, signalPhase, signalState, generatedAtTime, minEndTime, maxEndTime, observation, store, lastPhaseStart, lastPhase, phaseStart, maxDidIncrease } = returnObject;\r\n                let observationUTC = Helper.splitDateInParts(phaseStart);\r\n                let phaseDuration = new Date(generatedAtTime).getTime() - new Date(lastPhaseStart).getTime();\r\n                this.timeDistribution.add(signalGroup, lastPhase, observationUTC[\"year\"], observationUTC[\"month\"], observationUTC[\"day\"], observationUTC[\"hour\"], Math.floor(observationUTC[\"minute\"]/20)*20, Math.round(phaseDuration/1000));\r\n                let distribution = this.timeDistribution.get(signalGroup,signalPhase,observationUTC[\"year\"],observationUTC[\"month\"],observationUTC[\"day\"],observationUTC[\"hour\"],Math.floor(observationUTC[\"minute\"]/20)*20);\r\n                console.log(distribution);\r\n                let likelyTime = PredictionManager.predictLikelyTime(signalGroup, signalPhase, generatedAtTime, minEndTime, maxEndTime, lastPhaseStart, distribution, PredictionCalculator.calculateMedianDuration, maxDidIncrease);\r\n                likelyTime && store.addQuad(signalState.object, namedNode('https://w3id.org/opentrafficlights#likelyTime'), literal(likelyTime,namedNode(\"http://www.w3.org/2001/XMLSchema#date\")), observation.subject);\r\n\r\n            },\r\n            (returnObject) => {\r\n                let { signalGroup, signalPhase, signalState, generatedAtTime, minEndTime, maxEndTime, observation, store, lastPhaseStart, lastPhase, phaseStart, maxDidIncrease } = returnObject;\r\n                let observationUTC = Helper.splitDateInParts(phaseStart);\r\n                let distribution = this.timeDistribution.get(signalGroup,signalPhase,observationUTC[\"year\"],observationUTC[\"month\"],observationUTC[\"day\"],observationUTC[\"hour\"],Math.floor(observationUTC[\"minute\"]/20)*20);\r\n                console.log(distribution);\r\n                let likelyTime = PredictionManager.predictLikelyTime(signalGroup, signalPhase, generatedAtTime, minEndTime, maxEndTime, lastPhaseStart, distribution, PredictionCalculator.calculateMedianDuration, maxDidIncrease);\r\n                likelyTime && store.addQuad(signalState.object, namedNode('https://w3id.org/opentrafficlights#likelyTime'), literal(likelyTime,namedNode(\"http://www.w3.org/2001/XMLSchema#date\")), observation.subject);\r\n            },\r\n            undefined\r\n            ,\r\n            async (returnObject) => {\r\n                let { store, prefixes } = returnObject;\r\n                await Helper.writeN3Store(store, prefixes).then((res) => {result = res});\r\n            }\r\n        );\r\n        return result;\r\n    };\r\n}\r\n\r\n","import React, { Component } from 'react';\r\nimport Countdown from \"./Countdown/Countdown.js\";\r\nimport MinMaxTable from \"./MinMaxTable/MinMaxTable.js\";\r\nimport BarChart from \"./Graph/BarChart.js\";\r\nimport PhaseColorGraph from \"./PhaseColorGraph/PhaseColorGraph.js\";\r\nimport \"./PredictionBox.css\";\r\nimport Downloader from \"../../../Parser/Downloader\";\r\nimport FragmentHandler from \"../../../Parser/FragmentHandler\";\r\nimport Dropdown from \"./Selector/Dropdown\";\r\nimport ErrorBox from \"./Error/ErrorBox\";\r\nimport PredictionGenerator from \"../../../Prediction/PredictionGenerator\";\r\n\r\nexport default class PredictionBox extends Component{\r\n    constructor(props){\r\n        super(props);\r\n        this.DATASET_URL = props.datasetUrl;\r\n        this._constructGraphData =this._constructGraphData.bind(this);\r\n        this._constructColorGraphData = this._constructColorGraphData.bind(this);\r\n        this._constructSignalGroup = this._constructSignalGroup.bind(this);\r\n        this.setActiveSignalGroup = this.setActiveSignalGroup.bind(this);\r\n        if(props.clientSidePrediction){\r\n            this.predictionGenerator = new PredictionGenerator();\r\n        }\r\n        this.state = {\r\n            clientSidePrediction: props.clientSidePrediction,\r\n            data: {},\r\n            colorData: {},\r\n            colorDataOldest: {},\r\n            minEndTimeGraphData: {},\r\n            maxEndTimeGraphData: {},\r\n            likelyTimeGraphData: {},\r\n            signalGroups: {},\r\n            activeSignalGroup: \"https://opentrafficlights.org/id/signalgroup/K648/4\",\r\n        };\r\n    }\r\n\r\n    componentDidMount() {\r\n        let { clientSidePrediction } = this.state;\r\n        setInterval(() => {\r\n            Downloader.download(this.DATASET_URL).then(async (fragment) => {\r\n                let parsed = fragment;\r\n                if(clientSidePrediction){\r\n                    parsed = await this.predictionGenerator.generatePredictions(fragment);\r\n                }\r\n                FragmentHandler.handleFragment(parsed).then((returnObject) => {\r\n                    // console.log(\"download success:\"+this.DATASET_URL);\r\n                    this.setState({\r\n                        data: returnObject,\r\n                    });\r\n                    this._constructGraphData(\"minEndTime\", \"minEndTimeGraphData\");\r\n                    this._constructGraphData(\"maxEndTime\", \"maxEndTimeGraphData\");\r\n                    this._constructGraphData(\"likelyTime\", \"likelyTimeGraphData\");\r\n                    this._constructColorGraphData();\r\n                    this._constructSignalGroup(Object.keys(returnObject));\r\n                });\r\n            }).catch(() => {\r\n                    this.setState({\r\n                        data: {},\r\n                    });\r\n                    console.error(\"data error: \"+this.DATASET_URL);\r\n                }\r\n            );\r\n        }, 1000);\r\n    }\r\n\r\n    _constructColorGraphData(){\r\n        let {data, colorData, colorDataOldest} = this.state;\r\n        Object.keys(data).forEach((signalGroup) => {\r\n            if(data[signalGroup]){\r\n                if(!colorData[signalGroup]){\r\n                    colorData[signalGroup] = {};\r\n                }\r\n                if(!colorData[signalGroup][data[signalGroup].signalPhase]){\r\n                    colorData[signalGroup][data[signalGroup].signalPhase] = [];\r\n                }\r\n                if(!colorDataOldest[signalGroup]){\r\n                    colorDataOldest[signalGroup] = [];\r\n                }\r\n                if(colorDataOldest[signalGroup].length > 20){\r\n                    let deletedPhase = colorDataOldest[signalGroup].shift();\r\n                    colorData[signalGroup][deletedPhase].shift();\r\n                }\r\n                let generatedAtTime = data[signalGroup] && data[signalGroup].generatedAtTime;\r\n                colorData[signalGroup][data[signalGroup].signalPhase].push({x: generatedAtTime, y: 1});\r\n                colorDataOldest[signalGroup].push(data[signalGroup].signalPhase);\r\n            }\r\n        });\r\n        let newState = {};\r\n        newState.colorData = colorData;\r\n        newState.colorDataOldest = colorDataOldest;\r\n        this.setState(newState);\r\n    }\r\n\r\n    _constructGraphData(type, graph){\r\n        let {data} = this.state;\r\n        let graphData = this.state[graph];\r\n        Object.keys(data).forEach((signalGroup) => {\r\n            if(data[signalGroup]){\r\n                if(!graphData[signalGroup]){\r\n                    graphData[signalGroup] = [];\r\n                }\r\n                if(graphData[signalGroup] && graphData[signalGroup].length > 20){\r\n                    graphData[signalGroup].shift();\r\n                }\r\n                let generatedAtTime = data[signalGroup] && data[signalGroup].generatedAtTime;\r\n                let countdown = data[signalGroup] && (new Date(data[signalGroup][type]).getTime() - new Date(data[signalGroup].generatedAtTime)) / 1000;\r\n                graphData[signalGroup].push({x: generatedAtTime, y: countdown});\r\n            }\r\n        });\r\n        let newState = {};\r\n        newState[graph] = graphData;\r\n        this.setState(newState);\r\n    }\r\n\r\n    _constructSignalGroup(newSignalGroups){\r\n        let { signalGroups, activeSignalGroup } = this.state;\r\n        newSignalGroups.forEach((sg) => {\r\n            signalGroups[sg] = 0;\r\n            if(activeSignalGroup === undefined){\r\n                activeSignalGroup = sg;\r\n            }\r\n        });\r\n        this.setState({\r\n            signalGroups: signalGroups,\r\n            activeSignalGroup: activeSignalGroup,\r\n        });\r\n    }\r\n\r\n    setActiveSignalGroup(signalGroup){\r\n        console.log(signalGroup);\r\n        this.setState({\r\n            data: {},\r\n            colorData: {},\r\n            colorDataOldest: {},\r\n            minEndTimeGraphData: {},\r\n            maxEndTimeGraphData: {},\r\n            likelyTimeGraphData: {},\r\n            activeSignalGroup: signalGroup,\r\n        });\r\n    }\r\n\r\n    render(){\r\n        let { signalGroups, activeSignalGroup, data, minEndTimeGraphData, maxEndTimeGraphData, likelyTimeGraphData, colorData } = this.state;\r\n        let signalGroup = activeSignalGroup;\r\n        let countdown = data[signalGroup] && data[signalGroup].likelyTime && (data[signalGroup].likelyTime.getTime() - data[signalGroup].generatedAtTime) / 1000;\r\n        if (countdown) countdown = Math.round(countdown*10)/10;\r\n        let minEndTime = data[signalGroup] && (data[signalGroup].minEndTime.getTime() - data[signalGroup].generatedAtTime) / 1000;\r\n        let maxEndTime = data[signalGroup] && (data[signalGroup].maxEndTime.getTime() - data[signalGroup].generatedAtTime) / 1000;\r\n        let color = \"-1\";\r\n        if(data[signalGroup]){\r\n            if(data[signalGroup].signalPhase === \"https://w3id.org/opentrafficlights/thesauri/signalphase/6\"\r\n                || data[signalGroup].signalPhase === \"https://w3id.org/opentrafficlights/thesauri/signalphase/5\"){\r\n                color = 6;\r\n            }\r\n            else if(data[signalGroup].signalPhase === \"https://w3id.org/opentrafficlights/thesauri/signalphase/3\"\r\n                || data[signalGroup].signalPhase === \"https://w3id.org/opentrafficlights/thesauri/signalphase/2\"){\r\n                color = 3;\r\n            }\r\n            else if(data[signalGroup].signalPhase === \"https://w3id.org/opentrafficlights/thesauri/signalphase/0\"){\r\n                color = 0;\r\n            }\r\n        }\r\n\r\n        let redData = [];\r\n        let greenData = [];\r\n        let orangeData = [];\r\n        colorData[signalGroup] && (Array.prototype.push.apply(redData,colorData[signalGroup][\"https://w3id.org/opentrafficlights/thesauri/signalphase/3\"]));\r\n        colorData[signalGroup] && (Array.prototype.push.apply(redData,colorData[signalGroup][\"https://w3id.org/opentrafficlights/thesauri/signalphase/2\"]));\r\n        colorData[signalGroup] && (Array.prototype.push.apply(greenData, colorData[signalGroup][\"https://w3id.org/opentrafficlights/thesauri/signalphase/6\"]));\r\n        colorData[signalGroup] && (Array.prototype.push.apply(greenData, colorData[signalGroup][\"https://w3id.org/opentrafficlights/thesauri/signalphase/5\"]));\r\n        colorData[signalGroup] && (Array.prototype.push.apply(orangeData, colorData[signalGroup][\"https://w3id.org/opentrafficlights/thesauri/signalphase/0\"]));\r\n\r\n        // if(Object.keys(data).length === 0){\r\n        //     return(\r\n        //         <ErrorBox message={\"No data returned: \"+this.DATASET_URL}/>\r\n        //     )\r\n        // }\r\n\r\n        return (\r\n            <div className=\"PredictionBox\">\r\n                <Dropdown options={signalGroups} activeValue={activeSignalGroup} onChange={this.setActiveSignalGroup}/>\r\n                <Countdown count={countdown} color={color} className=\"PredictionBox_Countdown\"/>\r\n                <MinMaxTable min={minEndTime} max={maxEndTime} className=\"PredictionBox_MinMaxTable\"/>\r\n                <BarChart minData={minEndTimeGraphData[signalGroup]} maxData={maxEndTimeGraphData[signalGroup]} likelyData={likelyTimeGraphData[signalGroup]} className=\"PredictionBox_BarChart\"/>\r\n                <PhaseColorGraph red={redData} green={greenData} orange={orangeData} className=\"PredictionBox_PhaseColorGraph\"/>\r\n                <p>After refresh of the page, it can take a few minutes before the first predictions will appear.</p>\r\n                {Object.keys(data).length === 0 && <ErrorBox message={\"No data returned: \"+this.DATASET_URL}/>}\r\n            </div>\r\n        )\r\n    }\r\n}","import React, { Component } from 'react';\r\nimport './CompareView.css';\r\nimport PredictionBox from \"../PredictionBox/PredictionBox\";\r\n\r\nexport default class CompareView extends Component{\r\n    render(){\r\n\r\n        return (\r\n            <div className=\"CompareView\">\r\n                <div className=\"CompareView_left\">\r\n                    <PredictionBox datasetUrl={'https://lodi.ilabt.imec.be/observer/rawdata/latest'} clientSidePrediction={true}/>\r\n                </div>\r\n                <div className=\"CompareView_right\">\r\n                    <PredictionBox datasetUrl={'http://localhost:8080/latest'}/>\r\n                </div>\r\n            </div>\r\n        )\r\n    }\r\n}","import React from 'react';\nimport './App.css';\nimport Drawer from \"./Visualizer/Drawer.js\";\nimport \"./Visualizer/Drawer.css\";\nimport \"./Visualizer/SignalGroupDrawer.js\";\nimport CompareView from \"./Visualizer/Components/CompareView/CompareView.js\";\nimport SignalGroupDrawer from \"./Visualizer/SignalGroupDrawer\";\nimport PredictionBox from \"./Visualizer/Components/PredictionBox/PredictionBox.js\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <div className=\"App-title\">OpenTrafficLightsPredictor</div>\n        {/*<Drawer/>*/}\n        {/*<SignalGroupDrawer/>*/}\n        <PredictionBox datasetUrl={'https://lodi.ilabt.imec.be/observer/rawdata/latest'} clientSidePrediction={true}/>\n        {/*<PredictionBox datasetUrl={'http://localhost:8080/latest'}/>*/}\n        {/*<CompareView/>*/}\n      </header>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}